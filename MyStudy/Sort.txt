퀵 정렬

기본적으로 분할정복 성격을 띄고 대표적으로 사용되는 정렬 알고리즘이다.
1. 피벗을 하나 선택하고
2. 내부에 모든 값을 검사하며 피벗보다 작으면 왼쪽 크면 오른쪽으로 배치하게끔 한다
3. 작업 진행 후 나누어진 두 배열에서 다시 피벗을 만들어 재귀적으로 정렬을 진행한다.
4. 더 이상 쪼개지지 않을 때 까지 진행


int partition (int arr[], int p, int r){
    int low, high;
    int pivot = arr[p]; // pivot 값 설정
 
    low = p + 1; // low 는 pivot의 바로 다음 위치에서부터
    high = r; // high는 전달된 끝지점
 
    while(low <= high){
        while(arr[low] < pivot) low++; // pivot 보다 작은 값이 나올때마다 이동
        while(arr[high] > pivot) high--; // pivot 보다 큰 값이 나올때마다 이동
 
        if (low <= high){ // low와 high 가 중단된 지점이 서로 위치가 역전된 지점이 아니라면
            int temp = arr[low];    // low 와 high 의 값 변경
            arr[low] = arr[high];
            arr[high] = temp;
        }
    }
 
    // 피벗과 high 위치 교환
    int temp = arr[p];
    arr[p] = arr[high];
    arr[high] = temp;
 
    return high; // 피벗 위치 반환
 
}
 
void quick_sort(int arr[], int left, int right){
    if (left < right){
        int pivot = partition(arr, left, right);
 
        quick_sort(arr, left, pivot-1); // 피벗을 기준으로 왼쪽 배열 정렬
        quick_sort(arr, pivot+1, right); // 피벗 기준으로 오른쪽 배열 정렬
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

버블 정렬

서로 인접한 두 원소를 검사하여 정렬
인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.

1. 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를, 세 번째와 네 번째를, … 이런 식으로 
(마지막-1)번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬한다.

2. 1회 진행 후 가장 큰 자료가 맨 뒤로 이동하므로 2회에서는 맨 끝에 있는 자료는 정렬에서 제외되고, 
2회 진행 후 끝에서 두 번째 자료까지는 정렬에서 제외된다.

3. 정렬을 1회 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

병합 정렬

병합정렬은 분할 정복 기법과 재귀 알고리즘을 이용해서 정렬 알고리즘
즉, 주어진 배열을 원소가 하나 밖에 남지 않을 때까지 계속 둘로 쪼갠 후에 다시 크기 순으로 재배열 하면서 원래 크기의 배열로 합침.


1. 나누어진 배열의 길이가 1이 될때까지 배열을 반으로 계속 나눈다.
2. 나누어진 배열을 합치면서 정렬을 수행하면서 합친다.
3. 합칠때는 합칠 두 배열의 길이의 총합만큼의 별도 배열을 준비해서 두 배열에서 작은 순서대로 가져와서 배열에 넣어준다.