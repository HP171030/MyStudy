1. 객체지향 프로그래밍이란 ?

프로그래밍에 필요한 데이터들을 추상화하여 상태와 행위를 가진 객체로 만들고 그 객체들 끼리 상호작용을 통한 로직을 구성하는 프로그래밍을 말한다.
객체는 데이터와 식별자에 의해 참조되는 공간을 말한다. 값을 의미하는 변수와 작업을 수행할 메서드를 연관된것들끼리 묶어 만든 것을 객체라 할 수 있다.

2. 객체지향 프로그래밍의 5대 원칙과 특징?
5대 설계원칙은 SOLID 원칙이 있습니다. 단일책임, 개방폐쇄, 리스코프치환, 인터페이스 분리, 의존역전이 있다. 

단일책임은 한 클래스는 하나의 책임만 져야한다. 
개방폐쇄는 코드 확장에는 개방적이고 수정에는 폐쇄적이어야 한다. 
리스코프 치환원칙은 하위 객체는 상위객체의 역할을 대신 수행 할 수 있어야한다. 
인터페이스는 클라이언트는 자신이 사용하는 메서드에만 의존 즉, 사용하지 않는 인터페이스에는 변경이 생기더라도 어떠한 영향도 끼치지 않도록 클라이언트가 필요로 하는 인터페이스를 각각 분리해야 한다는 뜻이고 
의존역전은 상위 모듈은 하위 모듈에 의존해서는 안되고 추상화에 의존해야 한다는 뜻입니다. 

특징은 상속, 추상화, 캡슐화, 다형성의 특징이 있다.

상속은 새로운 클래스가 기존의 클래스의 속성과 기능을 물려받는 것이고, 
추상화는 인터페이스와 추상클래스로 구현되는데 복잡하고 디테일한 부분을 숨기고 본질적인 부분만을 노출시키는 것을 말한다.
캡슐화는 객체의 속성을 보호하고 외부의 접근을 제한시키는 기법을 말하고 
다형성은 동일한 인터페이스나 메서드 이름을 사용해서 서로 다른 객체가 서로 다른 동작을 하도록 하는 성질을 말한다. 
주로 오버로딩이나 오버라이딩을 통해 구현된다.

3. 상속을 사용하는 이유와 나의 상속활용 사례
상속을 사용하면 클래스를 구조적으로 만들 수 있어 복잡한 시스템을 파악하기에 좋고, 일관된 기능은 부모클래스에서 확장하거나 수정하므로 코드 유지보수에 용이하다.
사례는 유니티에서 오브젝트 관리를 위해 모노비헤이비어 클래스를 상속받아 사용, 오브젝트 간에도 몬스터, 플레이어 컨트롤러, 매니저 등을 상속하여 사용했었다.

4. 죽음의 다이아몬드란 ?
다중상속이 가능한 경우 생기는 문제이다. 어떤 클래스가 한 클래스의 기능을 상속받은 두 클래스를 다중상속 받는 경우 가장 위에 있는 부모의 기능을 사용하기 위해서 
다중상속 받은 두 클래스의 기능중 어떤 클래스의 기능을 사용해야 하는지에 대한 모호성에서 나타나는 문제이다. 이를 막기 위해 자바나 C#에서는 다중상속을 막고 인터페이스를 사용한다

5. 가비지콜렉터의 장단점은?
런타임 도중 사용하지 않는 메모리를 자동으로 회수하여 메모리 누수를 방지하고 관리하는 기능을 가비지콜렉터라고 한다.
장점은 개발자가 따로 메모리를 해제하지 않아도 자동으로 메모리를 누수를 방지하기 때문에 프로그램 안정성 관리에 편하다는 점이고 
단점은 가비지 콜렉터의 작동 시점이 예측 불가능하다는 점, 작동시 추가적인 CPU점유, 메모리사용 등으로 인해 오버헤드가 발생할수 있다는 점, 
이로 인해 실시간 시스템이 중요한 경우 일시적으로 느려지는 경우 문제가 치명적으로 이어질 수 있다는 점 등이 있습니다.

세대별 가비지 컬렉션 : 새롭게 생겨난 객체부터 0세대로 이 이상 살아남는 세대를 1세대 다음 2세대 .. 식으로 점점 생애주기가 긴 객체를 살아남는 식으로 하여
중요도에 따른 가비지 컬렉션을 진행하는 방식이다. 해당 가비지 컬렉션 방식으로 전체 메모리 사용량을 줄이고 최적화된 가비지컬렉팅을 진행할 수 있다.
메이저 컬렉션을 통해 Old Gen을 수거할 수 있다. 
메이저 컬렉션은 : 메모리가 부족, 세대가 가득 찼을 때, 메모리 사용 패턴에 따라 (0,1세대 수거 이후에도 2세대가 많다면),개발자 강제 호출,비동기 작업 이후(객체 생성이 많다면)
등 상황에 따라 진행한다.

6.구조체와 클래스의 차이점은?
구조체는 값타입, 
클래스는 참조타입 
생성 시 구조체 인스턴스는 값 자체를 복사하여 생성하여 스택메모리에 저장되고
클래스 인스턴스는 힙 메모리에 저장되고 주소를 참조한다.
구조체는 비교적 작고 단순한 데이터를 할당할때, 
클래스는 대규모, 복잡한 데이터를 할당할때 사용하며, 
구조체는 상속을 지원하지 않고 클래스는 지원한다
구조체를 쓰는 이유는 비교적 간단한 데이터 집합들을 사용할때 스택메모리에 할당하고 해제하는 작은 데이터 관리에 용이하기 때문이고
클래스는 참조타입이라 데이터 상태를 공유하는 등 상호작용이 가능해서 OOP 원칙을 적용하여 더욱 구조적인 코드를 짤때 용이하다.

7. 콜바이벨류 콜바이레퍼런스 차이
함수 호출 시 매개변수를 전달할때 실제로 값을 복사해서 전달하는지, 주소를 참조해서 전달하는지에 대한 차이
기본적으로 콜바이벨류를 사용하고 특정 상황을 유도하기 위해 콜바이레퍼런스를 사용했다. (ref,out,in)

8. 오버로딩과 오버라이딩의 차이?
이름은 비슷한데 개념이 좀 다르다. 
둘다 다형성과 관련있는데 오버로딩은 메서드의 이름을 같게하고 매개변수에 타입이나 갯수에 차이를 둬서 다형성을 추가한 기능이다.
이를 통해 코드 유지보수와 가독성을 향상시킬 수 있다.
오버라이딩은 상위 클래스에서 정의된 가상 함수를 하위 클래스에서 재정의하여 기능을 변경하거나 확장하는 기능을 말한다.

9. C#에 존재하는 두가지 타입은 무엇이고 이에 대해 설명
값 타입과 참조타입. 
값타입은 데이터를 직접 스택메모리에 할당되는 타입입니다. 
기본 데이터타입들이 이에 포함됩니다. 
int,float, double, enum, struct, char, bool 등.
참조타입은 힙 메모리에 할당되고 변수는 그 주소를 참조하는 타입. 주소는 스택에 저장됩니다. 
string, class, array, delegate 등

10. C#에서 포인터 쓰는 방법은?
언세이프 키워드를 사용해서 타입*로 변수에 메모리주소를 참조시킬수 있다..


11. 델리게이트란? 이벤트는? 
델리게이트(delegate)는 특정 시그니쳐를 따르는 메서드 참조를 나타내는 타입이다.
여러 메서드를 참조시킬 수 있고 이를 동적으로 호출할 수 있다.
주로 이벤트나 콜백메서드를 사용할 때 활용한다.
이벤트(event)는 델리게이트를 기반으로 만든 상태변화나 특정 조건시 통보해주는 옵저버패턴 알림 시스템이다
이를 통해 객체간 통신이 가능한다.알림을 알리는 발행자와, 알림을 받고 반응하는 구독자 간의 느슨한 결합을 지원한다

옵저버 패턴은 객체의 상태변화나 조건이 => 다른 객체들에게 자동으로 통보되어 업데이트 되는 디자인패턴이다.
이벤트에 다른 객체의 특정 반응을 구독, 해제 한다거나, 반대로 다른 객체의 이벤트에 유연하게 메서드를 구독, 해제할 수 있는 객체 상호 간 느슨한 결합으로 
코드 확장 및 유지보수 용이함이 장점이다.

12. const 붙이는 위치에 따라 어떤 차이가 있는지 
클래스 내부에서 상수 선언 : static과 같음. 컴파일시 값이 결정되고 이후 변경되지 않음.
메서드 내부에서 상수 선언 : 지역상수는 해당 지역(메서드 내부)에서 선언되고 이후 변경되지 않지만 해당 지역에서만 유효함.
매개변수로 받는 경우 : 값타입으로 상수를 받는 경우 매개변수를 변경 할 수 없다.
                     참조 타입의 경우에는 내부 프로퍼티로 접근 가능하다면 변경이 가능하다.

13. enum과 enum class의 차이
    enum은 같은 스코프 내에서 접근하고 타입안정성이 낮고 기본타입이 정수형으로 고정이지만
    enum class는 별도의 스코프에서 접근해서 별도 타입으로 취급되기 때문에 타입안정성이 높고 기본 타입을 지정할 수 있다.

14. static 키워드에 대해서
   해당 타입이 로드될 때 한번 데이터 영역에 할당되고 프로그램이 끝날때 까지 유지된다.
   클래스 또는 구조체의 멤버(필드,메서드, 프로퍼티 등)에 적용할 수 있고 인스턴스와 관계 없이 클래스나 구조체에 종속되어 사용된다.즉 인스턴스를 생성하지 않고도 타입을 통해 접근할 수 있다

15. 인터페이스의 특징
    OOP에서 구현해야하는 메서드 집합을 강제하는 일종의 계약이다. 인터페이스 자체는 메서드 구현내용을 정의하지 않고 시그니쳐만 정의하며 클래스에서 반드시 구현해야한다.
   추상클래스와의 차이는 추상클래스는 클래스로서 하위기능으로의 확장, 즉 클래스와의 의미있는 연관관계 기능을 구축할때 사용하고 인터페이스는 자유롭게 연관되지 않아도 필요에 의해 관계를 맺게 할 수 있다.
   예를 들어 생물은 호흡을 해야하니 추상클래스인 생물에 호흡메서드가 붙고 이하 모든 생물은 호흡을 하는 메서드를 필요로 하겠지만, 생물과 관련없는 점프 기능(인터페이스)은 필요에 의해 붙일수 있는것이다.

16.프로퍼티란 ? 
  클래스 속성에 대한 접근방법을 제어한다. Get으로 속성 값에 접근하고 Set으로 속성 값을 설정할 수 있다.
   변수에 대한 직접적인 접근방법을 제어하고 캡슐화를 지원하는 역할을 한다.

17.이터레이터란? 사용해본 경험은?
   컬렉션에 순차적으로 접근할 수 있게 만드는 객체이다. 내부구조를 숨기고 코드에서 간단하게 요소를 탐색할 수 있다. 
   IEnumerator,IEnumerable을 이용하여 유니티의 코루틴, foreach문을 사용했다.

18. Collection 에 대하여 (자료구조) 
∙ Vector 와 List 의 차이는?
   벡터 : C#의 배열,배열리스트와 비슷한 구조로 연속적인 데이터 컬렉션. 이론상 탐색,삽입,삭제가 O(n)이지만 연속적이라 캐시친화도가 높아 속도가 빠르다.
   리스트 : C#의 와 더블링크드리스트와 비슷한구조로 비연속적 데이터 컬렉션. 이론상 탐색은 O(n),삽입,제거 속도가 O(1)이지만 캐시친화도가 낮아 속도가 느리다
∙ Stack 과 Queue 의 차이점은? 
   스택 : 선입후출 데이터 컬렉션, 요소를 쌓고 빼는 구조
    큐 : 선입선출 데이터 컬렉션, 앞에서 추가하고 뒤에서 빠지는 구조
∙ Dictionary 란 무엇인가? 
    Key - Value 쌍 구조로 주로 해시타입을 띄고 있는 데이터 컬렉션 데이터를 효율적으로 조회, 추가, 수정, 삭제 가능하다.
    보통 비연속적 구조로 작성하기 때문에 캐시친화도가 낮을 수 있다.
∙ Linked List 란? 
    데이터를 저장하는 선형 자료구조의 일종이다. 각 요소가 포인터를 통하여 다른 요소와 연결되어있는 구조이다.
    데이터와 포인터로 나뉘어져있는 노드로 구성되어있다.  데이터는 실 데이터 값, 포인터는 다음 요소를 가리키는 참조
    단일 a => b 더블 a <=> b 원형 a => b => a 등의 종류가 있다.
    동적으로 크기를 조정할 수 있어 배열보다 유연하고 삽입 삭제가 빠른 장점이 있지만
    탐색할때 인덱스에 직접 접근할 수가 없으니까 느리고, 노드에 값 뿐 아니라 포인터도 담아야해서 오버헤드가 발생할 수 있으며, 비연속적이라 단편화도 잦아서 성능저하를 일으킬 수 있다.


∙ List, Dictionary 중 무엇이 더 빠를지? 
   상황에 따라 다른데 캐시친화도 대문에 일반적인 순차접근 탐색이 잦을시 리스트가 빠르지만 키 값 접근과 빈번한 삽입 삭제 시 딕셔너리가 빠르다

1. 랜덤 맵 생성은 어떤 방식으로 이루어지는건지?
다양한 알고리즘을 절차적으로 진행하여 완성됩니다.
에 적용된 변수를 받아 맵 크기와 타일 종류를 정의하는 등 초기 설정을 거치고, 방이라는 클래스를 세대라는 클래스에 리스트로 관리하여 트리구조로 설계했습니다.
방은 유니티의 콜라이더를 비롯한 물리연산을 활용하여 충돌검사를 진행하여 적절히 배치하고 세대를 통해 방의 깊이 속성을 결정지었습니다. 방의 위치와 속성이 결정되면 해당 정보를 토대로 
맵 상태를 배열화하여 포톤의 RPC함수를 통해 나머지 유저들에게 동기화시킵니다. 배열전송이 완료되면 모든 유저는 비트마스킹을 활용한 오토타일링을 진행하고
각종 오브젝트를 넘겨받은 CSV와 리소스를 읽어 구조에 맞게 포톤의 룸오브젝트 생성 함수로 배치합니다. 모든 과정이 끝나면 시야시스템으로 활용할 그림자, 전장의 안개, 플레이어 생성 등 마무리작업을 진행합니다.


2.랜덤 맵 생성 시스템에서 방을 자연스럽게 생성하기 위해 어떤 알고리즘을 사용했나요?
셀룰러 오토마타 기법을 사용하였습니다.
정해진 규칙에 따라 입력을 읽으면서 내부의 상태를 바꾸고 결과를 출력하는 기계의 수학적 모델인데요
현재 배열 주위 8칸을 검사해서 상태를 확인하고 벽이 아닌 셀의 수가 특정 기준을 넘어가면 복도아이디로 변환시켰습니다.

3.맵의 방을 세대별로 관리하는 이유와 그 장점은 무엇인가요?
구조적으로 관리하기가 편합니다. 세대는 첫 세대부터 깊이가 얕아질수록 후 세대로 넘어가게 됩니다. 세대를 통해서 레벨이 높은 오브젝트는 깊이가 깊은 세대에 배치를 하고
레벨이 낮은 오브젝트는 얕은 곳에 배치하여 랜덤하지만 레벨에 따라 방의 설정을 동적으로도 조정할 수 있어 실시간으로도 방의 모든 요소를 관리 할 수 있습니다.


4. 사용자 정의 검증 절차에 따른 방 생성 로직을 어떻게 설계했나요?
첫 세대의 방을 월드 중앙에 배치하고 해당 세대에서부터 초기 설정에 따라 조건에 맞지 않으면 무한루프를 돌면서 겹치지않게 물리연산을 진행하며 방을 상하좌우로 트리구조로 배치합니다.그리고 해당 오브젝트의
스케일 정보와 세대 속성정보를 통해 배열을 구성하고, 배열은 포톤의 RPC를 통해 나머지 플레이어들에게 넘깁니다.


랜덤 맵 생성 과정에서 방의 크기나 배치는 어떻게 결정되나요?
유니티에 맵 생성관리 오브젝트에 초기 설정을 할 수 있는 변수를 직렬화하여 크기와 배치를 설정할 수 있습니다.

방을 List로 관리한 이유가 무엇일까요?
리스트는 탐색이 빠르기 때문에 랜덤으로 방의 정보를 가져오는 과정에서 적절하다고 생각합니다. 맵 제작시 이루어 지는 세대별 방 생성은 이후에 게임 내에서 삭제되거나 삽입되지 않기 때문에
리스트를 사용했습니다.


세대별 방 관리가 던전의 균형과 구조에 미치는 영향은 무엇인가요?
세대 즉 깊이 별로 방의 밸런스레벨을 조절 관리하기가 편합니다.

맵 배열화를 통해 얻을 수 있는 이점은 무엇인가요?
맵의 크기를 디테일하게 조절할 수 있다는 점이라고 생각합니다.


배열화를 마친 후 RPC를 통해 배열을 공유할 때, 어떤 방식으로 동기화하나요?
2차원 배열을 1차원으로 만들고 해당 배열을 청크로 나누어 비동기적으로 나머지 플레이어들에게 RPC로 공유합니다
모든 청크 갯수가 충족이 되면 나누어진 청크롤 완성시키고 다시 2차원 배열로 만들었습니다.
- 오버헤드가 발생하진 않을까요? 네 그래서 고민해본게 배열을 압축시키는 방법을 생각했습니다.
예를 들어 청크화 시킬때 해당 행으로 0이 끝까지 이루어져 있다면 해당 끝 갯수만큼 0을 행의 크기만큼 할당하라는 식으로 데이터를 압축시킬수 있을거라고 생각했습니다.


비트마스킹을 사용한 오토타일링 구현 과정에 대해 설명해 주세요.
모든 배열을 순회하면서 타겟 배열중심으로 주위에 어떤 타일id가 배치되어있는지 확인하면 해당 배열이 어떤 속성이고 어떤 위치에 있는지 확정 할수 있습니다.


비트마스킹을 사용하여 타일을 선택하는 기준은 무엇인가요?
해당 배열 주위 8칸이 어떻게 배치되어있는지 확인하는 것이 기준입니다.

게임매니저가 맵 생성 후 각 오브젝트 매니저를 초기화하는 로직은 어떻게 설계되었나요?
맵이 완성되면 오브젝트별로 구성된 매니저들을 미리 만들 	어진 CSV로 값을 받아 이를 토대로 세대에 따라 랜덤으로 해당 오브젝트를 생성시킵니다.


맵 생성 후 함정, 몬스터, 퍼즐 등의 오브젝트를 어떻게 랜덤 배치했나요?
세대에 따른 방 리스트를 불러와 랜덤으로 방의 정보를 불러왔고 방의 정보에 해당 방의 크기가 어떻고 위치가 어딘지 있기 때문에 랜덤 배치를 할 수 있었습니다.


유니티 라이프 사이클 설명
awake onenable start fixedupdate ontrigger oncollision update lateupdate ondisable ondestroy
맵 생성기의 여러 검증절차가 무엇인지?

방 생성시 리스트에 넣어 세대별로 관리하는데 왜 리스트 썼는지?
방 생성 이후에 상호작용하는 작업은 삽입 삭제는 필요없고 탐색만 하면 되기 때문에 리스트가 적합한 자료구조라고 생각했습니다.


비트마스킹을 이용한 오토타일링 어떻게 진행하는지?

주변 8칸의 타일 상태를 검사하여 비트 패턴으로 표현하고,
미리 정의된 마스크 패턴과 비교하여 일치하는 경우 알맞은 타일을 배치하는 방법입니다. 이를 통해 자연스럽게 타일이 자동으로 깔리도록 구현할 수 있습니다.

시야시스템 어떻게 구축한건지?
유니티에 있는 2D라이트을 사용해서 빛을 표현하고 섀도우 캐스팅2D를 리플렉션을 통해 내부 변수를 조작해서 타일 컬라이더의 엣지를 받을 수 있게끔 해서 그림자를 표현했습니다.
이게 작동방식이 라이트가 그림자오브젝트를 통과할 수 없게 되어있는 형식이라 맵 전체 크기와 벽 타일컬라이더를 연결해서 벽의 그림자를 표현해봤습니다. 


리플렉션 사용했는데 내부 필드값 어떻게 뭘 변경한건지?
어 섀도우캐스터 2D 비공식필드인 메쉬와 섀도패스에 접근해서 타일컬라이더 엣지정보를 받아서 벡터를 리스트로 따오고 그 정점을 기반으로새로운 그림자메쉬를 만들수 있게 만든겁니다.


그림자 경로 얘기 했는데 무슨 얘긴지?
아무래도 전체 맵 크기는 정점이 많아서 당연히 맵 외곽으로 그림자를 그려야하고 맵 내부에 생기는 엄폐물 타일은 새로 그림자를 외곽이 아닌 내부에 그려야하는데 엄폐물은 정점이 적으니까 갯수로 외부와 내부를 특정한겁니다.

퀴즈 로직은 어떻게 구성되어 있는건지?
퀴즈는 퍼즐방에 생성되는데 퀴즈가 시작되면 마스터 클라이언트에서 퀴즈 진행상황을 관리하고 퍼즐방에 진입하고 나가는 것으로 참가와 퇴장 여부가 결정됩니다.
이는 유니티의 OnTriggerEnter 와 Exit를 활용해서 만들었고 퀴즈내용에 관한 부분은 기획팀이 만든 CSV를 받아 만들었습니다.

골렘퍼즐 골렘 기준으로 동적으로 방향 재정립한다는게 무슨 소린지?

정보세팅을 오브젝트 생성 후에 받아올수있게 비동기적으로 대기한 후에 정보를
받아오는거같은데 왜 Task.Yield를 사용했는지?
-비동기 프로그래밍에 대해 배우면서 유연하고 가독성 있는 코드를 만들고 싶어서 선택했습니다.
물론 이 기능을 구현하는 데 있어 코루틴을 사용해 조건이 충족될 때까지 대기하는 간단한 방법도 있긴 했습니다. 하지만
프로젝트 진행 중 네트워크 관련 작업을 위해 TCS(TaskCompletionSource)를 활용해 커스텀 프로퍼티의 정보를 받을 때까지 기다리는 확장 메서드를 만들었었는데
그 과정에서 비동기 프로그래밍에 대한 이해를 높이고, Task를 활용해보는 것도 배우고 싶어서 해당 방식으로 구현해보았습니다. 

파이어베이스 인증기능과 파이어베이스 DB 써본 구체적 사례

유니티 최적화기법 어떤거 써봤는지
오브젝트풀링 써본적 있습니다. 전체 오브젝트 풀은 딕셔너리로 
인스턴스아이디를 키로 만들어 관리했고
풀의 내용물은 스택으로 만들어 사용했습니다.
오클루젼 컬링을 사용해 카메라에 보이지 않는 부분은 렌더링 하지 않게해서 최적화 해봤고
라이트매핑도 사용해봤고 LOD도 사용해본적 있습니다.


프로파일러가 뭔지? 성능을 분석하고 최적화하는 도구인데 CPU,GPU,메모리 사용량 등을
실시간으로 모니터링하여 프레임단위로 성능문제를 파악할 수 있습니다.

스크립터블 오브젝트로 뭐 만들어봤는지

유니티 패키지 뭐 써봤는지
시네머신,인풋시스템,

깃허브 어떤식으로 써봤는지
SVN써봤는지 둘이 무슨 차이가 있는지?

CSV는 어떻게 사용하는건지?
CSV 파일을 읽어와 ICsvReadable 인터페이스를 구현한 구조체에 데이터를 매핑하여 딕셔너리에 저장했습니다. 이를 통해 데이터를 구조화하여 쉽게 접근하고 관리할 수 있도록 했습니다.

도움말 순환큐 리버스 메서드가 좀 안좋아 보이는데 이거 왜 이렇게 만든건지?
제가봐도 좀 비효율적으로 만든 것 같습니다.. 
지금은 만약 만든다면 큐 내부에서 인덱스포인터 두개를 만들어서 프론트와 리어 포인터 두개가 교차하거나 겹칠때까지 서로 스왑하도록 만들 것 같습니다.


비트플래그가 왜 효율적일거라 생각하는지?
불리언값은 1바이트라 참,거짓에 8비트를 소모하는데 비해 비트플래그를 사용하면
인티져값은 하나에 32비트 0부터 31까지 한번에 다 담을 수 있어 효율적인데다가
상태의 중복까지 표현가능하기 때문에 효율적이라고 생각합니다.

네트워크 상태관리 TCS 썼는데 어떤 방식을 사용한건지?
TaskCompletionSource 클래스를 활용해 커스텀 프로퍼티의 설정 작업을 비동기로 처리할수 있도록 만들었습니다.
네트워크 사이에서 정보가 오갔는지 성공 여부를 추적할 수 있도록 해서 플레이어의 프로퍼티 변경이 완료될 때까지 대기할 수 있으며, 
키-값 쌍을 관리하는 딕셔너리로 만들어진 스토리지를 사용해서 프로퍼티 작업을 순서대로 처리될 수 있게 만들었습니다. 


레이스컨디션이 뭔지?
두 개 이상의 스레드가 동시에 공유 자원에 접근하여 데이터를 변경할 때 발생하는 문제로, 결과가 실행 순서에 따라 달라지는 상황을 말합니다. 
이로 인해 예기치 않은 결과나 데이터 불일치가 발생할 수 있습니다.

관전기능 어떻게 구현한건지?

플레이어 목록에서 비활성 플레이어를 필터링한 후, 현재 카메라 인덱스를 기반으로 다음 플레이어로 카메라를 전환하는 방식으로 구성되었습니다. 
카메라 전환 시, 선택된 플레이어의 정보를 업데이트하고, 해당 플레이어의 위치를 기반으로 카메라를 이동시키는 이벤트를 등록했습니다.

공격속도 기능은 뭐 어떻게 한건지?
공격 속도는 주어진 최소 및 최대 지연 시간 범위에서, CSV 파서에 정의된 딕셔너리의 키값을 기준으로 계산하여 적절한 지연 시간을 반환하는 방식으로 구현되었습니다. 공격 속도가 딕셔너리의 최대 키값을 초과하지 않도록 제한하며, 계산된 지연 시간은 공격 속도에 따라 동적으로 조정됩니다.

스킬 구매하는 부분에서 리플렉션 이용했는데 어떻게 구조로 짜여져 있는건지?
처음 스킬을 구매할때는 리플렉션을 통해서 해당 스킬에 해당하는 컴포넌트를 가져오도록 했고 딕셔너리에 캐싱했습니다.
이후 다시 스킬을 재 구매할때는 스킬 딕셔너리에 캐싱이 되어있다면 바로 string을 키값으로 리턴하도록 만들어 최적화했습니다.


리플렉션이 뭔지?
코드의 메타데이터를 검사하고 조작할 수 있는 기능을 의미합니다. 주로 객체의 타입, 메서드, 속성, 이벤트 등을 동적으로 조회하거나 변경하는 데 사용

시간역행기술 비효율적으로 보이는데 다른 방법은 없었는지?

시간역행기술 비효율적으로 보이는데 다른 방법은 없었는지?
- 해당 기술을 구현하기 위해 큐에 위치정보와 체력을 담았었는데
지금은 프레임단위로 저장하는게 비효율적이라고 생각하긴 합니다
그래서 만약 제가 추후에 비슷한 기능을 구현한다면 
일정 간격으로 예를 들어 3초간 0.5초마다 상태를 기록하고 필요에 따라 
디큐된 데이터 사이를 선형보간 등으로 예측하여 자연스럽게 구현하려 할것같습니다


1. 주니어 개발자와 시니어 개발자의 차이
주니어 개발자는 주로 기초적인 기술과 지식을 바탕으로 주어진 작업을 수행하는 역할을 맡는 반면, 시니어 개발자는 문제 해결 능력과 시스템 설계, 아키텍처에 대한 깊은 이해를 바탕으로 프로젝트를 이끌어가는 역할을 합니다. 시니어 개발자는 또한 팀원들에게 멘토링을 제공하고, 더 넓은 시각에서 문제를 바라보며 전략적으로 접근하는 능력이 요구됩니다.

2. 개발이 적성에 잘 맞는지
네, 개발이 제 적성에 잘 맞는다고 생각합니다. 문제를 분석하고 해결하는 과정에서 창의성을 발휘할 수 있으며, 새로운 기술을 배우고 적용하는 과정이 항상 흥미롭습니다. 개발은 반복적인 과정이 아닌 지속적으로 성장할 수 있는 분야라고 느끼기 때문에, 제 성격과 잘 어울립니다.

3. 자신이 가진 역량
저는 문제 해결 능력과 협업 능력이 회사와 직무에 잘 맞다고 생각합니다. 문제를 구조적으로 분석하고, 팀원들과 효과적으로 소통하여 다양한 의견을 수렴하고 최적의 해결책을 찾는 데 강점을 가지고 있습니다. 이러한 역량은 특히 R&D 팀에서 기술적 도전 과제를 해결하는 데 큰 도움이 될 것입니다.

4. 개발자로서의 목표
저의 단기 목표는 기술 스택을 더욱 깊게 이해하고, 프로젝트를 통해 실력을 쌓는 것입니다. 5년 후에는 중급 개발자로서 팀을 이끌 수 있는 역할을 맡고, 10년 후에는 기술적인 리더십을 가진 시니어 개발자가 되어 혁신적인 프로젝트를 추진하고 싶습니다. 또한, 후배 개발자들에게 지식을 전수하는 멘토 역할도 수행하고 싶습니다.

5. 압박감이 클 때의 효율적인 작업
압박감이 클 때는 우선 우선순위를 정리하여 가장 중요한 작업부터 해결하는 방식을 취합니다. 시간을 잘 관리하고, 필요할 때는 동료와의 소통을 통해 문제를 공유하여 다양한 관점을 얻습니다. 이런 접근은 제 스트레스를 줄이고, 보다 효과적으로 문제를 해결하는 데 도움이 됩니다.

6. 개발자에게 가장 중요한 역량
개발자에게 가장 중요한 역량은 문제 해결 능력이라고 생각합니다. 기술적 문제를 효과적으로 분석하고, 다양한 접근 방식을 시도하여 해결책을 찾아내는 능력은 개발 과정에서 필수적입니다. 이 외에도 지속적인 학습과 협업 능력도 중요하며, 변화하는 기술 환경에 적응하고 팀과 원활하게 소통하는 능력이 필수적입니다.

전공이 직무와 안 맞는데 직무(개발자)를 선택한 이유는 무엇인가요?
개발이 매력적이고 신기하고 재밌었기 때문입니다. 
처음은 게임을 직접 개발해보고 싶다는 열망에 방향성을 잡기 시작했습니다. 그 과정에서 여러 프로젝트를 경험했고 하면 할수록 제가 생각해낸 것이 이렇게 직접적으로 눈앞에 보이는 모습이 참 좋다고 생각했습니다.
그리고 학습할수록 점점 생각하는 범위가 넓어지고 다른 사람들이 만들어놓은 알고리즘이나 코드를 읽는것도 신기하고 재밌었습니다.

전공자와 비교했을 때 본인이 경쟁력이 있다고 생각하는지 궁금해요.
스스로 개발 기술을 습득하며 적극적으로 학습하는 태도가 저를 경쟁력 있게 만들어 준다고 생각합니다.

전공 지식을 어떻게 보완할 것인지 설명해 주세요.
전공 지식을 보완하기 위해 깃이나 구글을 통해 지속적으로 학습하고 있고 코딩테스트를 통해서 문제해결 능력을 기르고 있습니다.

전공과 다른 진로를 선택하게 된 계기가 있다면 무엇인가요?

 인생의 방향성을 다시 한 번 고민하는 시간을 가진적이 있습니다. 처음에는 사회복지사업을 전공하며 아이들을 돌보는 일을 했고, 삶의 안정성을 찾아 사회복지공무원도 준비한 적이 있었습니다.

하지만 시간이 지남에 따라 제가 진정으로 좋아하는 일이 뭔지 깨닫게 되었고, 게임 개발에 대한 꿈을 다시 찾게 되었습니다.

지금은 클라이언트 개발자를 궁극적인 목표로 삼고 있습니다. 늦었지만 제가 겪었던 모든 일들이 저의 방향성을 확립하는데 많은 도움이 되었다고 생각합니다.


비전공자로서 전공자들과 섞여서 일했을 때 본인의 강점이 무엇이라고 생각하나요?
음.. 저는 사회복지사업을 전공헀는데 사회복지사업은 여러 이해관계자의 의견을 수렴하고, 데이터 분석을 통해 문제의 본질을 파악하는 데 능숙합니다. 
이러한 경험을 바탕으로 프로젝트의 도전과제를 명확히 이해하고, 시스템 설계 및 구현 과정에서 발생하는 문제를 효과적으로 해결할 수 있을것이라 생각합니다.

센터에서 다양한 사회적 문제에 직면한 아동들을 지원하는 프로그램을 운영하고 있었는데, 프로그램을 개선하기 위해, 아동과 부모님, 그리고 지역 사회의 피드백을 수집했습니다. 
이 정보를 바탕으로 아동들이 가장 필요로 하는 지원 서비스를 식별하고, 기존 프로그램을 수정하여 더 많은 참여를 이끌어냈습니다.

학습 지원 프로그램을 운영하면서 아동들의 학업 성취도가 낮다는 데이터를 분석하였고, 그 결과 맞춤형 학습 지원을 제공하게 되었습니다. 