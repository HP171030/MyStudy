1. 객체지향 프로그래밍이란 ?

프로그래밍에 필요한 데이터들을 추상화하여 상태와 행위를 가진 객체로 만들고 그 객체들 끼리 상호작용을 통한 로직을 구성하는 프로그래밍을 말한다.
객체는 데이터와 식별자에 의해 참조되는 공간을 말한다. 값을 의미하는 변수와 작업을 수행할 메서드를 연관된것들끼리 묶어 만든 것을 객체라 할 수 있다.

2. 객체지향 프로그래밍의 5대 원칙과 특징?
5대 설계원칙은 SOLID 원칙이 있습니다. 단일책임, 개방폐쇄, 리스코프치환, 인터페이스 분리, 의존역전이 있다. 

단일책임은 한 클래스는 하나의 책임만 져야한다. 
개방폐쇄는 코드 확장에는 개방적이고 수정에는 폐쇄적이어야 한다. 
리스코프 치환원칙은 하위 객체는 상위객체의 역할을 대신 수행 할 수 있어야한다. 
인터페이스는 클라이언트는 자신이 사용하는 메서드에만 의존 즉, 사용하지 않는 인터페이스에는 변경이 생기더라도 어떠한 영향도 끼치지 않도록 클라이언트가 필요로 하는 인터페이스를 각각 분리해야 한다는 뜻이고 
의존역전은 상위 모듈은 하위 모듈에 의존해서는 안되고 추상화에 의존해야 한다는 뜻입니다. 

특징은 상속, 추상화, 캡슐화, 다형성의 특징이 있다.

상속은 새로운 클래스가 기존의 클래스의 속성과 기능을 물려받는 것이고, 
추상화는 인터페이스와 추상클래스로 구현되는데 복잡하고 디테일한 부분을 숨기고 본질적인 부분만을 노출시키는 것을 말한다.
캡슐화는 객체의 속성을 보호하고 외부의 접근을 제한시키는 기법을 말하고 
다형성은 동일한 인터페이스나 메서드 이름을 사용해서 서로 다른 객체가 서로 다른 동작을 하도록 하는 성질을 말한다. 
주로 오버로딩이나 오버라이딩을 통해 구현된다.

3. 상속을 사용하는 이유와 나의 상속활용 사례
상속을 사용하면 클래스를 구조적으로 만들 수 있어 복잡한 시스템을 파악하기에 좋고, 일관된 기능은 부모클래스에서 확장하거나 수정하므로 코드 유지보수에 용이하다.
사례는 유니티에서 오브젝트 관리를 위해 모노비헤이비어 클래스를 상속받아 사용, 오브젝트 간에도 몬스터, 플레이어 컨트롤러, 매니저 등을 상속하여 사용했었다.

4. 죽음의 다이아몬드란 ?
다중상속이 가능한 경우 생기는 문제이다. 어떤 클래스가 한 클래스의 기능을 상속받은 두 클래스를 다중상속 받는 경우 가장 위에 있는 부모의 기능을 사용하기 위해서 
다중상속 받은 두 클래스의 기능중 어떤 클래스의 기능을 사용해야 하는지에 대한 모호성에서 나타나는 문제이다. 이를 막기 위해 자바나 C#에서는 다중상속을 막고 인터페이스를 사용한다

5. 가비지콜렉터의 장단점은?
런타임 도중 사용하지 않는 메모리를 자동으로 회수하여 메모리 누수를 방지하고 관리하는 기능을 가비지콜렉터라고 한다.
장점은 개발자가 따로 메모리를 해제하지 않아도 자동으로 메모리를 누수를 방지하기 때문에 프로그램 안정성 관리에 편하다는 점이고 
단점은 가비지 콜렉터의 작동 시점이 예측 불가능하다는 점, 작동시 추가적인 CPU점유, 메모리사용 등으로 인해 오버헤드가 발생할수 있다는 점, 
이로 인해 실시간 시스템이 중요한 경우 일시적으로 느려지는 경우 문제가 치명적으로 이어질 수 있다는 점 등이 있습니다.

6.구조체와 클래스의 차이점은?
구조체는 값타입, 
클래스는 참조타입 
생성 시 구조체 인스턴스는 값 자체를 복사하여 생성하여 스택메모리에 저장되고
클래스 인스턴스는 힙 메모리에 저장되고 주소를 참조한다.
구조체는 비교적 작고 단순한 데이터를 할당할때, 
클래스는 대규모, 복잡한 데이터를 할당할때 사용하며, 
구조체는 상속을 지원하지 않고 클래스는 지원한다
구조체를 쓰는 이유는 비교적 간단한 데이터 집합들을 사용할때 스택메모리에 할당하고 해제하는 작은 데이터 관리에 용이하기 때문이고
클래스는 참조타입이라 데이터 상태를 공유하는 등 상호작용이 가능해서 OOP 원칙을 적용하여 더욱 구조적인 코드를 짤때 용이하다.

7. 콜바이벨류 콜바이레퍼런스 차이
함수 호출 시 매개변수를 전달할때 실제로 값을 복사해서 전달하는지, 주소를 참조해서 전달하는지에 대한 차이
기본적으로 콜바이벨류를 사용하고 특정 상황을 유도하기 위해 콜바이레퍼런스를 사용했다. (ref,out,in)

8. 오버로딩과 오버라이딩의 차이?
이름은 비슷한데 개념이 좀 다르다. 
둘다 다형성과 관련있는데 오버로딩은 메서드의 이름을 같게하고 매개변수에 타입이나 갯수에 차이를 둬서 다형성을 추가한 기능이다.
이를 통해 코드 유지보수와 가독성을 향상시킬 수 있다.
오버라이딩은 상위 클래스에서 정의된 가상 함수를 하위 클래스에서 재정의하여 기능을 변경하거나 확장하는 기능을 말한다.

9. C#에 존재하는 두가지 타입은 무엇이고 이에 대해 설명
값 타입과 참조타입. 
값타입은 데이터를 직접 스택메모리에 할당되는 타입입니다. 
기본 데이터타입들이 이에 포함됩니다. 
int,float, double, enum, struct, char, bool 등.
참조타입은 힙 메모리에 할당되고 변수는 그 주소를 참조하는 타입. 주소는 스택에 저장됩니다. 
string, class, array, delegate 등

10. C#에서 포인터 쓰는 방법은?
언세이프 키워드를 사용해서 타입*로 변수에 메모리주소를 참조시킬수 있다..


11. 델리게이트란? 이벤트는? 
델리게이트(delegate)는 특정 시그니쳐를 따르는 메서드 참조를 나타내는 타입이다.
여러 메서드를 참조시킬 수 있고 이를 동적으로 호출할 수 있다.
주로 이벤트나 콜백메서드를 사용할 때 활용한다.
이벤트(event)는 델리게이트를 기반으로 만든 상태변화나 특정 조건시 통보해주는 옵저버패턴 알림 시스템이다
이를 통해 객체간 통신이 가능한다.알림을 알리는 발행자와, 알림을 받고 반응하는 구독자 간의 느슨한 결합을 지원한다

옵저버 패턴은 객체의 상태변화나 조건이 => 다른 객체들에게 자동으로 통보되어 업데이트 되는 디자인패턴이다.
이벤트에 다른 객체의 특정 반응을 구독, 해제 한다거나, 반대로 다른 객체의 이벤트에 유연하게 메서드를 구독, 해제할 수 있는 객체 상호 간 느슨한 결합으로 코드 확장 및 유지보수 용이함이 장점이다.

12. const 붙이는 위치에 따라 어떤 차이가 있는지 
클래스 내부에서 상수 선언 : static과 같음. 컴파일시 값이 결정되고 이후 변경되지 않음.
메서드 내부에서 상수 선언 : 지역상수는 해당 지역(메서드 내부)에서 선언되고 이후 변경되지 않지만 해당 지역에서만 유효함.
매개변수로 받는 경우 : 값타입으로 상수를 받는 경우 매개변수를 변경 할 수 없다.
                     참조 타입의 경우에는 내부 프로퍼티로 접근 가능하다면 변경이 가능하다.

13. enum과 enum class의 차이
    enum은 같은 스코프 내에서 접근하고 타입안정성이 낮고 기본타입이 정수형으로 고정이지만
    enum class는 별도의 스코프에서 접근해서 별도 타입으로 취급되기 때문에 타입안정성이 높고 기본 타입을 지정할 수 있다.

14. static 키워드에 대해서
   해당 타입이 로드될 때 한번 데이터 영역에 할당되고 프로그램이 끝날때 까지 유지된다.
   클래스 또는 구조체의 멤버(필드,메서드, 프로퍼티 등)에 적용할 수 있고 인스턴스와 관계 없이 클래스나 구조체에 종속되어 사용된다.즉 인스턴스를 생성하지 않고도 타입을 통해 접근할 수 있다

15. 인터페이스의 특징
    OOP에서 구현해야하는 메서드 집합을 강제하는 일종의 계약이다. 인터페이스 자체는 메서드 구현내용을 정의하지 않고 시그니쳐만 정의하며 클래스에서 반드시 구현해야한다.
   추상클래스와의 차이는 추상클래스는 클래스로서 하위기능으로의 확장, 즉 클래스와의 의미있는 연관관계 기능을 구축할때 사용하고 인터페이스는 자유롭게 연관되지 않아도 필요에 의해 관계를 맺게 할 수 있다.
   예를 들어 생물은 호흡을 해야하니 추상클래스인 생물에 호흡메서드가 붙고 이하 모든 생물은 호흡을 하는 메서드를 필요로 하겠지만, 생물과 관련없는 점프 기능(인터페이스)은 필요에 의해 붙일수 있는것이다.

16.프로퍼티란 ? 
  클래스 속성에 대한 접근방법을 제어한다. Get으로 속성 값에 접근하고 Set으로 속성 값을 설정할 수 있다.
   변수에 대한 직접적인 접근방법을 제어하고 캡슐화를 지원하는 역할을 한다.

17.이터레이터란? 사용해본 경험은?
   컬렉션에 순차적으로 접근할 수 있게 만드는 객체이다. 내부구조를 숨기고 코드에서 간단하게 요소를 탐색할 수 있다. 
   IEnumerator,IEnumerable을 이용하여 유니티의 코루틴, foreach문을 사용했다.

18. Collection 에 대하여 (자료구조) 
∙ Vector 와 List 의 차이는?
   벡터 : C#의 배열,배열리스트와 비슷한 구조로 연속적인 데이터 컬렉션. 이론상 탐색,삽입,삭제가 O(n)이지만 연속적이라 캐시친화도가 높아 속도가 빠르다.
   리스트 : C#의 와 더블링크드리스트와 비슷한구조로 비연속적 데이터 컬렉션. 이론상 탐색은 O(n),삽입,제거 속도가 O(1)이지만 캐시친화도가 낮아 속도가 느리다
∙ Stack 과 Queue 의 차이점은? 
   스택 : 선입후출 데이터 컬렉션, 요소를 쌓고 빼는 구조
    큐 : 선입선출 데이터 컬렉션, 앞에서 추가하고 뒤에서 빠지는 구조
∙ Dictionary 란 무엇인가? 
    Key - Value 쌍 구조로 주로 해시타입을 띄고 있는 데이터 컬렉션 데이터를 효율적으로 조회, 추가, 수정, 삭제 가능하다.
    보통 비연속적 구조로 작성하기 때문에 캐시친화도가 낮을 수 있다.
∙ Linked List 란? 
    데이터를 저장하는 선형 자료구조의 일종이다. 각 요소가 포인터를 통하여 다른 요소와 연결되어있는 구조이다.
    데이터와 포인터로 나뉘어져있는 노드로 구성되어있다.  데이터는 실 데이터 값, 포인터는 다음 요소를 가리키는 참조
    단일 a => b 더블 a <=> b 원형 a => b => a 등의 종류가 있다.
    동적으로 크기를 조정할 수 있어 배열보다 유연하고 삽입 삭제가 빠른 장점이 있지만
    탐색할때 인덱스에 직접 접근할 수가 없으니까 느리고, 노드에 값 뿐 아니라 포인터도 담아야해서 오버헤드가 발생할 수 있으며, 비연속적이라 단편화도 잦아서 성능저하를 일으킬 수 있다.


∙ List, Dictionary 중 무엇이 더 빠를지? 
   상황에 따라 다른데 캐시친화도 대문에 일반적인 순차접근 탐색이 잦을시 리스트가 빠르지만 키 값 접근과 빈번한 삽입 삭제 시 딕셔너리가 빠르다

   --- PortFolio 관련 ---
1. 랜덤 맵 생성은 어떤 방식으로 이루어지는건지?
다양한 알고리즘을 절차적으로 진행하여 완성됩니다.
유니티에디터에 적용된 변수를 받아 맵 크기와 타일 종류를 정의하는 등 초기 설정을 거치고, 방이라는 클래스를 세대라는 클래스에 리스트로 관리하여 트리구조로 설계했습니다.
방은 유니티의 콜라이더를 비롯한 물리연산을 활용하여 충돌검사를 진행하여 적절히 배치하고 세대를 통해 방의 깊이 속성을 결정지었습니다. 방의 위치와 속성이 결정되면 해당 정보를 토대로 
맵 상태를 배열화하여 포톤의 RPC함수를 통해 나머지 유저들에게 동기화시킵니다. 배열전송이 완료되면 모든 유저는 비트마스킹을 활용한 오토타일링을 진행하고
각종 오브젝트를 넘겨받은 CSV와 리소스를 읽어 구조에 맞게 포톤의 룸오브젝트 생성 함수로 배치합니다. 모든 과정이 끝나면 시야시스템으로 활용할 그림자, 전장의 안개, 플레이어 생성 등 마무리작업을 진행합니다.


랜덤 맵 생성 시스템에서 방을 자연스럽게 생성하기 위해 어떤 알고리즘을 사용했나요?

맵의 방을 세대별로 관리하는 이유와 그 장점은 무엇인가요?
사용자 정의 검증 절차에 따른 방 생성 로직을 어떻게 설계했나요?
랜덤 맵 생성 과정에서 방의 크기나 배치는 어떻게 결정되나요?
방을 List로 관리하는 방식이 맵 생성 과정에서 어떤 역할을 하나요?
세대별 방 관리가 던전의 균형과 구조에 미치는 영향은 무엇인가요?
맵 생성 과정에서 발생할 수 있는 불규칙한 방 배치를 어떻게 제어했나요?
인스펙터 창에서 맵 정보를 조절하는 기능은 어떻게 구현되었나요?
맵 배열화를 통해 얻을 수 있는 이점은 무엇인가요?
배열화를 마친 후 RPC를 통해 배열을 공유할 때, 어떤 방식으로 동기화하나요?
비트마스킹을 사용한 오토타일링 구현 과정에 대해 설명해 주세요.
비트마스킹을 사용하여 타일을 선택하는 기준은 무엇인가요?
오토타일링을 통해 맵의 시각적 일관성을 어떻게 유지했나요?
게임매니저가 맵 생성 후 각 오브젝트 매니저를 초기화하는 로직은 어떻게 설계되었나요?
오브젝트 매니저의 초기화 과정에서 발생할 수 있는 문제점과 해결 방안은 무엇이었나요?
맵 생성 후 함정, 몬스터, 퍼즐 등의 오브젝트를 어떻게 랜덤 배치했나요?
시야 시스템에서 그림자 영역을 가리기 위한 방법에 대해 설명해 주세요.
그림자를 통해 플레이어 시야를 제한하는 방식은 무엇인가요?
타일맵의 충돌체 정점을 기준으로 시야를 처리한 이유는 무엇인가요?
ShadowCaster2D의 내부 필드값을 리플렉션을 통해 변경한 이유와 방식은 무엇인가요?
긴 경로와 짧은 경로에 따른 그림자 처리 방식을 어떻게 구분했나요?
경로가 긴 경우 타일맵의 경계와 결합하여 그림자를 정의한 방법에 대해 설명해 주세요.
짧은 경로에서 타일맵 경로만으로 그림자를 정의하는 방식의 장점은 무엇인가요?
타일맵 외부로 그림자가 확장될 때 발생할 수 있는 문제와 그 해결 방법은 무엇이었나요?
맵의 각 셀을 검사하여 주변 9개 셀의 상태를 확인하는 로직은 어떻게 작동하나요?
셀룰러ID를 설정하여 복도를 지정하는 기준은 무엇인가요?
셀룰러ID 상태를 복도ID로 변환하는 과정에서 주의해야 할 점은 무엇인가요?
복도 구간을 자연스럽게 구현하기 위해 어떤 알고리즘을 사용했나요?
복도 구간을 설정할 때, 게임의 난이도나 플레이어 경험에 미치는 영향을 어떻게 고려했나요?
랜덤으로 생성된 방들이 서로 잘 연결되도록 하기 위한 로직은 무엇인가요?
던전 생성 과정에서 플레이어가 탐험할 수 있는 길을 어떻게 보장하나요?
복도와 방의 연결 상태가 잘못될 때 발생할 수 있는 문제는 무엇인가요?
맵 생성 중 장애물이나 벽을 배치할 때의 기준은 무엇이었나요?
맵 생성 시 벽이 아닌 셀을 어떻게 인식하여 복도로 지정하나요?
복도 구간을 생성할 때 다른 방들과의 충돌을 피하는 방법은 무엇인가요?
랜덤 맵 생성 시스템에서 성능 최적화를 위해 사용한 방법은 무엇인가요?
맵 생성 과정에서 타일맵이 너무 복잡해지지 않도록 제어한 방식은 무엇인가요?
랜덤하게 생성된 맵에서 플레이어 경험을 개선하기 위해 추가한 기능은 무엇이 있나요?
게임 내에서 방을 랜덤하게 배치할 때, 플레이어가 지루하지 않도록 만든 요소는 무엇인가요?
랜덤 생성된 던전에서 난이도 조절을 어떻게 관리했나요?
RPC를 통해 공유된 배열 데이터가 손상되었을 경우 어떻게 복구했나요?
랜덤 맵 생성 과정에서 디버깅이 어려운 문제를 어떻게 해결했나요?
각 방에 특정 오브젝트를 배치할 때 고려한 요소는 무엇인가요?
맵 생성기에서 방들이 특정 규칙을 따르도록 제어하는 방법은 무엇인가요?
플레이어가 맵을 탐험할 때 전략적 요소를 어떻게 추가했나요?
맵의 셀 상태를 검사할 때, 메모리 사용을 최소화하기 위한 방법은 무엇인가요?
복도와 방의 연결성 외에 다른 상호작용 요소를 추가한 사례가 있나요?
맵 생성 후 발생할 수 있는 불필요한 데이터 처리를 어떻게 최적화했나요?
랜덤 맵 생성 시스템을 테스트할 때 중요한 체크포인트는 무엇이었나요?
멀티플레이 환경에서 랜덤 맵 생성이 모든 클라이언트에서 일관되게 작동하도록 한 방법은 무엇인가요?
