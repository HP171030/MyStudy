1. 객체지향 프로그래밍이란 ?

프로그래밍에 필요한 데이터들을 추상화하여 상태와 행위를 가진 객체로 만들고 그 객체들 끼리 상호작용을 통한 로직을 구성하는 프로그래밍을 말한다.
객체는 데이터와 식별자에 의해 참조되는 공간을 말한다. 값을 의미하는 변수와 작업을 수행할 메서드를 연관된것들끼리 묶어 만든 것을 객체라 할 수 있다.

2. 객체지향 프로그래밍의 5대 원칙과 특징?
5대 설계원칙은 SOLID 원칙이 있습니다. 단일책임, 개방폐쇄, 리스코프치환, 인터페이스 분리, 의존역전이 있다. 

단일책임은 한 클래스는 하나의 책임만 져야한다. 
개방폐쇄는 코드 확장에는 개방적이고 수정에는 폐쇄적이어야 한다. 
리스코프 치환원칙은 하위 객체는 상위객체의 역할을 대신 수행 할 수 있어야한다. 
인터페이스는 클라이언트는 자신이 사용하는 메서드에만 의존 즉, 사용하지 않는 인터페이스에는 변경이 생기더라도 어떠한 영향도 끼치지 않도록 클라이언트가 필요로 하는 인터페이스를 각각 분리해야 한다는 뜻이고 
의존역전은 상위 모듈은 하위 모듈에 의존해서는 안되고 추상화에 의존해야 한다는 뜻입니다. 

특징은 상속, 추상화, 캡슐화, 다형성의 특징이 있다.

상속은 새로운 클래스가 기존의 클래스의 속성과 기능을 물려받는 것이고, 
추상화는 인터페이스와 추상클래스로 구현되는데 복잡하고 디테일한 부분을 숨기고 본질적인 부분만을 노출시키는 것을 말한다.
캡슐화는 객체의 속성을 보호하고 외부의 접근을 제한시키는 기법을 말하고 
다형성은 동일한 인터페이스나 메서드 이름을 사용해서 서로 다른 객체가 서로 다른 동작을 하도록 하는 성질을 말한다. 
주로 오버로딩이나 오버라이딩을 통해 구현된다.

3. 상속을 사용하는 이유와 나의 상속활용 사례
상속을 사용하면 클래스를 구조적으로 만들 수 있어 복잡한 시스템을 파악하기에 좋고, 일관된 기능은 부모클래스에서 확장하거나 수정하므로 코드 유지보수에 용이하다.
사례는 유니티에서 오브젝트 관리를 위해 모노비헤이비어 클래스를 상속받아 사용, 오브젝트 간에도 몬스터, 플레이어 컨트롤러, 매니저 등을 상속하여 사용했었다.

4. 죽음의 다이아몬드란 ?
다중상속이 가능한 경우 생기는 문제이다. 어떤 클래스가 한 클래스의 기능을 상속받은 두 클래스를 다중상속 받는 경우 가장 위에 있는 부모의 기능을 사용하기 위해서 
다중상속 받은 두 클래스의 기능중 어떤 클래스의 기능을 사용해야 하는지에 대한 모호성에서 나타나는 문제이다. 이를 막기 위해 자바나 C#에서는 다중상속을 막고 인터페이스를 사용한다

5. 가비지콜렉터의 장단점은?
런타임 도중 사용하지 않는 메모리를 자동으로 회수하여 메모리 누수를 방지하고 관리하는 기능을 가비지콜렉터라고 한다.
장점은 개발자가 따로 메모리를 해제하지 않아도 자동으로 메모리를 누수를 방지하기 때문에 프로그램 안정성 관리에 편하다는 점이고 
단점은 가비지 콜렉터의 작동 시점이 예측 불가능하다는 점, 작동시 추가적인 CPU점유, 메모리사용 등으로 인해 오버헤드가 발생할수 있다는 점, 
이로 인해 실시간 시스템이 중요한 경우 일시적으로 느려지는 경우 문제가 치명적으로 이어질 수 있다는 점 등이 있습니다.

6.구조체와 클래스의 차이점은?
구조체는 값타입, 
클래스는 참조타입 
생성 시 구조체 인스턴스는 값 자체를 복사하여 생성하여 스택메모리에 저장되고
클래스 인스턴스는 힙 메모리에 저장되고 주소를 참조한다.
구조체는 비교적 작고 단순한 데이터를 할당할때, 
클래스는 대규모, 복잡한 데이터를 할당할때 사용하며, 
구조체는 상속을 지원하지 않고 클래스는 지원한다
구조체를 쓰는 이유는 비교적 간단한 데이터 집합들을 사용할때 스택메모리에 할당하고 해제하는 작은 데이터 관리에 용이하기 때문이고
클래스는 참조타입이라 데이터 상태를 공유하는 등 상호작용이 가능해서 OOP 원칙을 적용하여 더욱 구조적인 코드를 짤때 용이하다.

7. 콜바이벨류 콜바이레퍼런스 차이
함수 호출 시 매개변수를 전달할때 실제로 값을 복사해서 전달하는지, 주소를 참조해서 전달하는지에 대한 차이
기본적으로 콜바이벨류를 사용하고 특정 상황을 유도하기 위해 콜바이레퍼런스를 사용했다. (ref,out,in)

8. 오버로딩과 오버라이딩의 차이?
이름은 비슷한데 개념이 좀 다르다. 
둘다 다형성과 관련있는데 오버로딩은 메서드의 이름을 같게하고 매개변수에 타입이나 갯수에 차이를 둬서 다형성을 추가한 기능이다.
이를 통해 코드 유지보수와 가독성을 향상시킬 수 있다.
오버라이딩은 상위 클래스에서 정의된 가상 함수를 하위 클래스에서 재정의하여 기능을 변경하거나 확장하는 기능을 말한다.

9. C#에 존재하는 두가지 타입은 무엇이고 이에 대해 설명
값 타입과 참조타입. 
값타입은 데이터를 직접 스택메모리에 할당되는 타입입니다. 
기본 데이터타입들이 이에 포함됩니다. 
int,float, double, enum, struct, char, bool 등.
참조타입은 힙 메모리에 할당되고 변수는 그 주소를 참조하는 타입. 주소는 스택에 저장됩니다. 
string, class, array, delegate 등

10. C#에서 포인터 쓰는 방법은?
언세이프 키워드를 사용해서 타입*로 변수에 메모리주소를 참조시킬수 있다..


11. 델리게이트란? 이벤트는? 
델리게이트(delegate)는 특정 시그니쳐를 따르는 메서드 참조를 나타내는 타입이다.
여러 메서드를 참조시킬 수 있고 이를 동적으로 호출할 수 있다.
주로 이벤트나 콜백메서드를 사용할 때 활용한다.
이벤트(event)는 델리게이트를 기반으로 만든 상태변화나 특정 조건시 통보해주는 옵저버패턴 알림 시스템이다
이를 통해 객체간 통신이 가능한다.알림을 알리는 발행자와, 알림을 받고 반응하는 구독자 간의 느슨한 결합을 지원한다

옵저버 패턴은 객체의 상태변화나 조건이 => 다른 객체들에게 자동으로 통보되어 업데이트 되는 디자인패턴이다.
이벤트에 다른 객체의 특정 반응을 구독, 해제 한다거나, 반대로 다른 객체의 이벤트에 유연하게 메서드를 구독, 해제할 수 있는 객체 상호 간 느슨한 결합으로 코드 확장 및 유지보수 용이함이 장점이다.

12. const 붙이는 위치에 따라 어떤 차이가 있는지 
클래스 내부에서 상수 선언 : static과 같음. 컴파일시 값이 결정되고 이후 변경되지 않음.
메서드 내부에서 상수 선언 : 지역상수는 해당 지역(메서드 내부)에서 선언되고 이후 변경되지 않지만 해당 지역에서만 유효함.
매개변수로 받는 경우 : 값타입으로 상수를 받는 경우 매개변수를 변경 할 수 없다.
                     참조 타입의 경우에는 내부 프로퍼티로 접근 가능하다면 변경이 가능하다.

13. enum과 enum class의 차이
    enum은 같은 스코프 내에서 접근하고 타입안정성이 낮고 기본타입이 정수형으로 고정이지만
    enum class는 별도의 스코프에서 접근해서 별도 타입으로 취급되기 때문에 타입안정성이 높고 기본 타입을 지정할 수 있다.

14. static 키워드에 대해서
   해당 타입이 로드될 때 한번 데이터 영역에 할당되고 프로그램이 끝날때 까지 유지된다.
   클래스 또는 구조체의 멤버(필드,메서드, 프로퍼티 등)에 적용할 수 있고 인스턴스와 관계 없이 클래스나 구조체에 종속되어 사용된다.즉 인스턴스를 생성하지 않고도 타입을 통해 접근할 수 있다

15. 인터페이스의 특징
    OOP에서 구현해야하는 메서드 집합을 강제하는 일종의 계약이다. 인터페이스 자체는 메서드 구현내용을 정의하지 않고 시그니쳐만 정의하며 클래스에서 반드시 구현해야한다.
   추상클래스와의 차이는 추상클래스는 클래스로서 하위기능으로의 확장, 즉 클래스와의 의미있는 연관관계 기능을 구축할때 사용하고 인터페이스는 자유롭게 연관되지 않아도 필요에 의해 관계를 맺게 할 수 있다.
   예를 들어 생물은 호흡을 해야하니 추상클래스인 생물에 호흡메서드가 붙고 이하 모든 생물은 호흡을 하는 메서드를 필요로 하겠지만, 생물과 관련없는 점프 기능(인터페이스)은 필요에 의해 붙일수 있는것이다.

16.프로퍼티란 ? 
  클래스 속성에 대한 접근방법을 제어한다. Get으로 속성 값에 접근하고 Set으로 속성 값을 설정할 수 있다.
   변수에 대한 직접적인 접근방법을 제어하고 캡슐화를 지원하는 역할을 한다.

17.이터레이터란? 사용해본 경험은?
   컬렉션에 순차적으로 접근할 수 있게 만드는 객체이다. 내부구조를 숨기고 코드에서 간단하게 요소를 탐색할 수 있다. 
   IEnumerator,IEnumerable을 이용하여 유니티의 코루틴, foreach문을 사용했다.

18. Collection 에 대하여 (자료구조) 
∙ Vector 와 List 의 차이는?
   벡터 : C#의 배열,배열리스트와 비슷한 구조로 연속적인 데이터 컬렉션. 이론상 탐색,삽입,삭제가 O(n)이지만 연속적이라 캐시친화도가 높아 속도가 빠르다.
   리스트 : C#의 와 더블링크드리스트와 비슷한구조로 비연속적 데이터 컬렉션. 이론상 탐색은 O(n),삽입,제거 속도가 O(1)이지만 캐시친화도가 낮아 속도가 느리다
∙ Stack 과 Queue 의 차이점은? 
   스택 : 선입후출 데이터 컬렉션, 요소를 쌓고 빼는 구조
    큐 : 선입선출 데이터 컬렉션, 앞에서 추가하고 뒤에서 빠지는 구조
∙ Dictionary 란 무엇인가? 
    Key - Value 쌍 구조로 주로 해시타입을 띄고 있는 데이터 컬렉션 데이터를 효율적으로 조회, 추가, 수정, 삭제 가능하다.
    보통 비연속적 구조로 작성하기 때문에 캐시친화도가 낮을 수 있다.
∙ Linked List 란? 
    데이터를 저장하는 선형 자료구조의 일종이다. 각 요소가 포인터를 통하여 다른 요소와 연결되어있는 구조이다.
    데이터와 포인터로 나뉘어져있는 노드로 구성되어있다.  데이터는 실 데이터 값, 포인터는 다음 요소를 가리키는 참조
    단일 a => b 더블 a <=> b 원형 a => b => a 등의 종류가 있다.
    동적으로 크기를 조정할 수 있어 배열보다 유연하고 삽입 삭제가 빠른 장점이 있지만
    탐색할때 인덱스에 직접 접근할 수가 없으니까 느리고, 노드에 값 뿐 아니라 포인터도 담아야해서 오버헤드가 발생할 수 있으며, 비연속적이라 단편화도 잦아서 성능저하를 일으킬 수 있다.


∙ List, Dictionary 중 무엇이 더 빠를지? 
   상황에 따라 다른데 캐시친화도 대문에 일반적인 순차접근 탐색이 잦을시 리스트가 빠르지만 키 값 접근과 빈번한 삽입 삭제 시 딕셔너리가 빠르다


